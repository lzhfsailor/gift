---
layout: post
title:  "粒子群优化算法（一）：原理"
date:   2014-04-30 15:45:15
categories: [all,tech,pso]
---
# 算法简介 #

----------

PSO算法是群智能算法的一种，模拟一群鸟寻找食物的过程。每个鸟就是PSO中的一个粒子，也就是我们需要求解问题的可能解，这些鸟在寻找食物的过程中，不停改变自己在空中飞行的位置与速度。
# 算法描述 #

----------

我们用pbest来记录个体搜索到的最优解，用gbest来记录整个群体在一次迭代中搜索到的最优解。速度和粒子位置的更新公式如下：
> - v[i] = w * v[i] + c1 * rand() * (pbest[i] - present[i]) + c2 * rand() * (gbest - present[i])
> - present[i] = present[i] + v[i]

其中v[i]代表第i个粒子的速度，w代表惯性权值,c1和c2表示学习参数，rand()表示在0-1之间的随机数,pbest[i]代表第i个粒子搜索到的最优值,gbest代表整个种群搜索到的最优值,present[i]代表第i个粒子的当前位置。

此外，微粒的速度V[i]被一个最大速度Vmax所限制。如果当前对微粒的加速导致它的在某维的速度vid超过该维的最大速度vmax,d，则该维的速度被限制为该维最大速度vmax,d。

标准PSO的算法流程如下：[来源于维基百科](http://zh.wikipedia.org/wiki/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96 "维基百科") 
> 1. 初始化一群粒子（群体规模为m），包括随机的位置和速度；
> 1. 评价每个粒子的适应度；
> 1. 对每个粒子，将它的适应值和它经历过的最好位置pbest的作比较，如果较好，则将其作为当前的最好位置pbest；
> 1. 对每个粒子，将它的适应值和全局所经历最好位置gbest的作比较，如果较好，则重新设置gbest的索引号；
> 1. 根据方程v[i]及present[i]来变化粒子的速度和位置；
> 1. 如未达到结束条件（通常为足够好的适应值或达到一个预设最大代数Gmax），回到2）。

----------
# 算法模型 #

----------
对于公式v[i]，第一部分为粒子先前行为的惯性，第二部分为“认知（cognition）”部分，表示粒子本身的思考；第三部分为“社会（social）”部分，表示微粒间的信息共享与相互合作。

1. 认知模型
	- 速度更新公式仅包含粒子群先前速度项（惯性）和粒子的认知部分，c2=0
	- v[i] = w * v[i] + c1 * rand() * (pbest[i] - present[i])
2. 社会模型
	- 速度更新公式仅包含粒子群先前速度项（惯性）和粒子的社会部分,c1=0
	- v[i] = w * v[i] + c2 * rand() * (gbest - present[i])
3. 完全模型
	- 速度更新公式仅包含所有像，c1≠0,且c2≠0
	- v[i] = w * v[i] + c1 * rand() * (pbest[i] - present[i]) + c2 * rand() * (gbest - present[i])
4. 自私模型
	- 速度更新公式中，群体最优选择时不包含粒子自身信息
	- v[i] = w * v[i] + c1 * rand() * (pbest[i] - present[i]) + c2 * rand() * (gbest' - present[i])
	- 其中gbest'=min{*f*(pbest[1]),*f*(pbest[2]),*f*(pbest[i-1]),*f*(pbest[i+1])……*f*(pbest[N])}
5. 随机模型
	- 速度更新公式中，不考虑粒子以前速度的影响（惯性），则粒子将会在搜索空间中随机移动，w=0
	- v[i] =c1 * rand() * (pbest[i] - present[i]) + c2 * rand() * (gbest - present[i])